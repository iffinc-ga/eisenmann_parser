<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Eisenmann Invoice PDF Parser</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:Arial, sans-serif;background:#f5f7fa;padding:20px}
    .container{max-width:1800px;margin:0 auto;background:#fff;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.1)}
    .header{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;padding:30px;border-radius:8px 8px 0 0}
    .header h1{margin-bottom:8px}
    .upload-section{padding:40px;text-align:center}
    .upload-box{border:3px dashed #cbd5e0;border-radius:8px;padding:40px;cursor:pointer;transition:.3s}
    .upload-box:hover{border-color:#667eea;background:#f7fafc}
    .upload-box.dragover{border-color:#667eea;background:#e6f0ff}
    #fileInput{display:none}
    .loading{padding:40px;text-align:center;display:none}
    .spinner{border:4px solid #f3f3f3;border-top:4px solid #667eea;border-radius:50%;width:50px;height:50px;animation:spin 1s linear infinite;margin:0 auto 20px}
    @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
    .controls{padding:20px;background:#f8f9fa;border-bottom:1px solid #dee2e6;display:none;position:sticky;top:0;z-index:100;align-items:center;gap:10px;flex-wrap:wrap}
    .controls select{padding:10px;border:1px solid #ced4da;border-radius:4px;font-size:14px;min-width:260px}
    .controls button{padding:10px 20px;border:none;border-radius:4px;font-weight:600;cursor:pointer}
    .btn-success{background:#28a745;color:#fff}.btn-success:hover{background:#218838}
    .btn-primary{background:#007bff;color:#fff}.btn-primary:hover{background:#0056b3}
    .btn-danger{background:#dc3545;color:#fff}.btn-danger:hover{background:#c82333}
    .btn-light{background:#f8f9fa;color:#212529;border:1px solid #ced4da}
    .inline-help{font-size:12px;color:#6c757d;margin-left:8px}
    .db-banner{padding:12px 20px;background:#fff3cd;border-bottom:1px solid #ffc107;font-size:13px;display:flex;align-items:center;gap:10px}
    .db-status{font-weight:600}
    .db-status.loading{color:#856404}
    .db-status.loaded{color:#155724}
    .db-status.offline{color:#6c757d}
    .db-btn{padding:4px 10px;border-radius:4px;border:1px solid #856404;background:#fff;font-size:11px;cursor:pointer}
    .stats{padding:20px;display:none;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:15px;background:#fff3cd}
    .stat{padding:15px;background:#fff;border-radius:4px;border-left:4px solid #ffc107}
    .stat-label{font-size:11px;color:#6c757d;text-transform:uppercase;margin-bottom:5px}
    .stat-value{font-size:20px;font-weight:700}
    .stat-value.error{color:#dc3545}.stat-value.success{color:#28a745}
    .stat input{width:100%;padding:6px;border:1px solid #ced4da;border-radius:3px;font-size:16px;font-weight:bold}
    .stat.editable{border-left-color:#007bff}
    .table-container{padding:20px;display:none}
    .table-header-wrapper{background:#343a40;overflow:auto}
    .table-header-wrapper::-webkit-scrollbar{display:none}
    .table-header-wrapper{scrollbar-width:none}
    .table-header{min-width:1532px}
    .table-header table{width:100%;border-collapse:collapse}
    .table-header th{background:#343a40;color:#fff;padding:8px;text-align:left;font-weight:600;font-size:13px;border:none}
    .table-body-wrapper{max-height:560px;overflow:auto}
    .table-body{min-width:1532px}
    .table-body table{width:100%;border-collapse:collapse}
    .table-body td{padding:6px 6px;border-bottom:1px solid #dee2e6;background:#fff}
    .table-body tr:hover td{background:#f8f9fa}
    .table-body td input{width:100%;padding:6px;border:1px solid #ced4da;border-radius:3px;font-size:13px}
    .table-body td select{width:100%;padding:6px;border:1px solid #ced4da;border-radius:3px;font-size:13px;background:#fff}
    .table-body td input:focus,.table-body td select:focus{outline:none;border-color:#667eea;box-shadow:0 0 0 2px rgba(102,126,234,.15)}
    .readonly{background:#e9ecef!important}
    .actions{text-align:center;white-space:nowrap}
    .actions button{padding:4px 8px;font-size:11px;margin:0 2px}
    .alert{margin:0 20px 20px;border-radius:4px;padding:10px 14px;font-size:13px;display:none}
    @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
    .table-header table,.table-body table{table-layout:fixed}
    .table-header th:nth-child(1),.table-body td:nth-child(1){width:52px!important}
    .table-header th:nth-child(2),.table-body td:nth-child(2){width:190px!important}
    .table-header th:nth-child(3),.table-body td:nth-child(3){width:80px!important}
    .table-header th:nth-child(4),.table-body td:nth-child(4){width:60px!important}
    .table-header th:nth-child(5),.table-body td:nth-child(5){width:110px!important}
    .table-header th:nth-child(6),.table-body td:nth-child(6){width:110px!important}
    .table-header th:nth-child(7),.table-body td:nth-child(7){width:110px!important}
    .table-header th:nth-child(8),.table-body td:nth-child(8){width:110px!important}
    .table-header th:nth-child(9),.table-body td:nth-child(9){width:100px!important}
    .table-header th:nth-child(10),.table-body td:nth-child(10){width:80px!important}
    .table-header th:nth-child(11),.table-body td:nth-child(11){width:100px!important}
    .table-header th:nth-child(12),.table-body td:nth-child(12){width:120px!important}
    .table-header th:nth-child(13),.table-body td:nth-child(13){width:110px!important}
    .metal-badge{display:inline-block;padding:2px 6px;margin:2px;border-radius:3px;font-size:11px;font-weight:600}
    .metal-steel{background:#c0c0c0;color:#333}
    .metal-copper{background:#b87333;color:#fff}
    .metal-aluminum{background:#a8a9ad;color:#fff}
    .metal-none{background:#d4edda;color:#155724;padding:4px 8px}
    .metal-info{font-size:11px;line-height:1.4}
    .country-melt{font-style:italic;color:#6c757d;font-size:10px;display:block;margin-top:2px}
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>üìÑ Eisenmann Invoice PDF Parser</h1>
    <p>Parse Eisenmann customs invoices into editable line items and export to Descartes CI template.</p>
  </div>

  <div class="db-banner">
    <span id="dbStatus" class="db-status loading">DB: not loaded</span>
    <span id="dbInfo">Will try to load updated_eisenmann_db.xlsx from GitHub...</span>
    <button id="retryDbBtn" class="db-btn">Retry DB</button>
    <button id="uploadDbBtn" class="db-btn">Upload DB File</button>
    <button id="offlineDbBtn" class="db-btn">Work offline</button>
    <input type="file" id="dbFileInput" accept=".xlsx" style="display:none" />
  </div>

  <div class="upload-section" id="uploadSection">
    <div class="upload-box" id="uploadBox">
      <h2>üì§ Upload Eisenmann PDF</h2>
      <p style="margin-top:10px;color:#6c757d">Click or drag &amp; drop your multi-invoice PDF here</p>
      <input type="file" id="fileInput" accept=".pdf,application/pdf" />
    </div>
  </div>

  <div class="loading" id="loading">
    <div class="spinner"></div>
    <div><strong>Processing PDF...</strong></div>
  </div>

  <div class="alert" id="alert"></div>

  <div class="controls" id="controls">
    <select id="invoiceSelect"><option value="">Select an invoice...</option></select>
    <button class="btn-success" onclick="exportToDescartes()">üìä Export to Descartes CI Template</button>
    <button class="btn-primary" onclick="resetUpload()">üì§ New Upload</button>
    <button class="btn-light" onclick="debugDumpData()">üêõ Debug: Dump Data</button>
    <span class="inline-help">Use Tab / Shift+Tab to move across cells. Edit invoice totals/dates at the top.</span>
  </div>

  <div class="stats" id="stats">
    <div class="stat">
      <div class="stat-label">Invoice Number</div>
      <div class="stat-value" id="statInvoice">-</div>
    </div>
    <div class="stat editable">
      <div class="stat-label">Invoice Date (Editable)</div>
      <input autocomplete="off" type="text" id="statDate" placeholder="MM/DD/YYYY"
             onchange="updateInvoiceField('invoice_date', this.value)">
    </div>
    <div class="stat editable">
      <div class="stat-label">Supplier (Editable)</div>
      <input autocomplete="off" type="text" id="statSupplier" placeholder="Supplier name"
             onchange="updateInvoiceField('supplier', this.value)">
    </div>
    <div class="stat">
      <div class="stat-label">Total Line Items</div>
      <div class="stat-value" id="statItems">0</div>
    </div>
    <div class="stat editable">
      <div class="stat-label">Invoice Total (Editable)</div>
      <input autocomplete="off" type="number" step="0.01" id="statTotal" placeholder="0.00"
             onchange="updateInvoiceTotal(this.value)">
    </div>
    <div class="stat">
      <div class="stat-label">Line Items Sum</div>
      <div class="stat-value" id="statSum">$0.00</div>
    </div>
    <div class="stat">
      <div class="stat-label">Difference</div>
      <div class="stat-value" id="statDiff">$0.00</div>
    </div>
  </div>

  <div class="table-container" id="tableContainer">
    <div class="table-header-wrapper">
      <div class="table-header">
        <table>
          <thead>
          <tr>
            <th>Pos</th>
            <th>Material / Part #</th>
            <th>Quantity</th>
            <th>Unit</th>
            <th>Unit Price</th>
            <th>Line Total</th>
            <th>Net Weight</th>
            <th>Country</th>
            <th>Metal Type</th>
            <th title="Metal percentage (typically 100)">Metal %</th>
            <th>Metal Wt (kg)</th>
            <th>Melt Country</th>
            <th>Actions</th>
          </tr>
          </thead>
        </table>
      </div>
    </div>
    <div class="table-body-wrapper">
      <div class="table-body">
        <table>
          <tbody id="tableBody"></tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<script>
  // ========= PDF.JS CONFIG =========
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

  // ========= GLOBAL STATE =========
  let allData = [];       // all line items for all invoices
  let currentInvoice = '';
  let invoiceOrder = [];
  let uploadedPdfName = '';

  // Database state
  let eisenmannDb = [];
  let htsCodesDb = [];
  let supplierMidDb = [];
  let steelAlumListDb = [];

  const uploadBox   = document.getElementById('uploadBox');
  const fileInput   = document.getElementById('fileInput');
  const loadingPane = document.getElementById('loading');
  const uploadSec   = document.getElementById('uploadSection');
  const alertBox    = document.getElementById('alert');
  const controls    = document.getElementById('controls');
  const stats       = document.getElementById('stats');
  const tableCont   = document.getElementById('tableContainer');
  const tbody       = document.getElementById('tableBody');
  const invoiceSelect = document.getElementById('invoiceSelect');

  // ========= DATABASE LOADING =========
  const GITHUB_CONFIG = {
    owner: 'iffinc-ga',
    repo: 'all_in_one_manki',
    branch: 'main',
    filePath: 'updated_eisenmann_db.xlsx'
  };

  const dbStatusEl = document.getElementById('dbStatus');
  const dbInfo = document.getElementById('dbInfo');
  const retryDbBtn = document.getElementById('retryDbBtn');
  const uploadDbBtn = document.getElementById('uploadDbBtn');
  const dbFileInput = document.getElementById('dbFileInput');
  const offlineDbBtn = document.getElementById('offlineDbBtn');

  function setDbBanner(state, msg, info) {
    if (!dbStatusEl) return;
    let cls = 'db-status';
    if (state === 'loading') cls += ' loading';
    else if (state === 'loaded') cls += ' loaded';
    else if (state === 'offline') cls += ' offline';
    dbStatusEl.className = cls;
    dbStatusEl.textContent = msg;
    if (dbInfo && info != null) dbInfo.textContent = info;
  }

  function abortableFetch(url, timeoutMs = 8000) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    return fetch(url, { signal: ctrl.signal }).finally(() => clearTimeout(t));
  }

  async function fetchAndReadWorkbook(url, useAbort) {
    const res = useAbort ? await abortableFetch(url, 8000) : await fetch(url);
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const buf = await res.arrayBuffer();
    return XLSX.read(buf, { type: 'array' });
  }

  async function hydrateDbFromWorkbook(workbook) {
    console.log('[DB] Available sheet names:', workbook.SheetNames);
    
    // Load Eisenmann sheet
    const eisenmannSheet = workbook.SheetNames.find(n => n.toLowerCase().includes('eisenmann')) || workbook.SheetNames[0];
    eisenmannDb = XLSX.utils.sheet_to_json(workbook.Sheets[eisenmannSheet], { defval: '' });
    console.log(`[DB] Loaded ${eisenmannSheet}: ${eisenmannDb.length} rows`);

    // Load HTS codes sheet if exists
    const htsSheet = workbook.SheetNames.find(n => n.toLowerCase().includes('hts'));
    if (htsSheet) {
      htsCodesDb = XLSX.utils.sheet_to_json(workbook.Sheets[htsSheet], { defval: '' });
      console.log(`[DB] Loaded ${htsSheet}: ${htsCodesDb.length} rows`);
    }

    // Load supplier MID sheet if exists
    const midSheet = workbook.SheetNames.find(n => n.toLowerCase().includes('mid'));
    if (midSheet) {
      supplierMidDb = XLSX.utils.sheet_to_json(workbook.Sheets[midSheet], { defval: '' });
      console.log(`[DB] Loaded ${midSheet}: ${supplierMidDb.length} rows`);
    }

    // Load Steel_Alum_list sheet - try multiple name patterns
    const steelAlumSheet = workbook.SheetNames.find(n => {
      const lower = n.toLowerCase().replace(/[_\s]/g, '');
      return lower.includes('steelalum') || n === 'Steel_Alum_list';
    });
    
    console.log('[DB] Looking for Steel_Alum_list sheet...');
    console.log('[DB] Found sheet name:', steelAlumSheet);
    
    if (steelAlumSheet) {
      steelAlumListDb = XLSX.utils.sheet_to_json(workbook.Sheets[steelAlumSheet], { defval: '' });
      console.log(`[DB] Loaded ${steelAlumSheet}: ${steelAlumListDb.length} rows`);
      if (steelAlumListDb.length > 0) {
        console.log('[DB] Steel_Alum_list columns:', Object.keys(steelAlumListDb[0]));
      }
    } else {
      console.warn('[DB] Steel_Alum_list sheet not found in workbook!');
    }

    setDbBanner('loaded', 'DB: Loaded successfully', `${eisenmannDb.length} parts`);
  }

  async function tryLoadDbFromGitHub() {
    try {
      setDbBanner('loading', 'DB: Loading from GitHub...', '');
      const rawUrl = `https://raw.githubusercontent.com/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/${GITHUB_CONFIG.branch}/${GITHUB_CONFIG.filePath}`;
      const wb = await fetchAndReadWorkbook(rawUrl, true);
      await hydrateDbFromWorkbook(wb);
    } catch (err) {
      console.error('[DB] GitHub load failed:', err);
      setDbBanner('offline', 'DB: Failed to load', 'Working offline without database');
    }
  }

  retryDbBtn.addEventListener('click', tryLoadDbFromGitHub);
  
  uploadDbBtn.addEventListener('click', () => {
    dbFileInput.click();
  });
  
  dbFileInput.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    
    try {
      setDbBanner('loading', 'DB: Loading from file...', '');
      const arrayBuffer = await file.arrayBuffer();
      const workbook = XLSX.read(arrayBuffer, { type: 'array' });
      await hydrateDbFromWorkbook(workbook);
    } catch (err) {
      console.error('[DB] File load failed:', err);
      setDbBanner('offline', 'DB: Failed to load file', err.message);
    }
  });
  
  offlineDbBtn.addEventListener('click', () => {
    setDbBanner('offline', 'DB: Working offline', 'Database features disabled');
  });

  // Try to load DB on startup
  tryLoadDbFromGitHub();

  // ========= DATABASE LOOKUP FUNCTIONS =========
  function lookupTariffsByPart(partNumber) {
    if (!eisenmannDb.length) return [];
    const upper = String(partNumber).toUpperCase().trim();
    // Try both column name formats for compatibility
    const row = eisenmannDb.find(r => 
      String(r['Part Number'] || r['PRIMARY PART NUM'] || '').toUpperCase().trim() === upper
    );
    if (!row) return [];
    
    const tariffs = [];
    // Check both old and new column name formats
    const tariffColumns = [
      'Tariff1', 'Tariff2', 'Tariff3', 'Tariff4', 'Tariff5',
      'TARIFF NUM', 'TARIFF NUM_1', 'TARIFF NUM_10', 'TARIFF NUM_19', 'TARIFF NUM_28'
    ];
    
    // Try old format first (Tariff1-5)
    for (let i = 1; i <= 5; i++) {
      const col = `Tariff${i}`;
      const val = String(row[col] || '').trim();
      if (val && val !== '0') tariffs.push(val);
    }
    
    // If no tariffs found, try new format (TARIFF NUM, TARIFF NUM_1, TARIFF NUM_10)
    if (tariffs.length === 0) {
      ['TARIFF NUM', 'TARIFF NUM_1', 'TARIFF NUM_10'].forEach(col => {
        const val = String(row[col] || '').trim();
        if (val && val !== '0' && val !== 'nan') tariffs.push(val);
      });
    }
    
    return tariffs;
  }

  function lookupHtsUom(htsCode) {
    if (!htsCodesDb.length) return { uom1: 'KG', uom2: '' };
    const code = String(htsCode).trim();
    const row = htsCodesDb.find(r => String(r['HTS Code'] || '').trim() === code);
    if (!row) return { uom1: 'KG', uom2: '' };
    
    return {
      uom1: String(row['UOM1'] || 'KG').trim(),
      uom2: String(row['UOM2'] || '').trim()
    };
  }

  function lookupSupplierMid(supplierName) {
    if (!supplierMidDb.length) return '';
    const upper = String(supplierName).toUpperCase().trim();
    const row = supplierMidDb.find(r => String(r['Supplier'] || '').toUpperCase().trim().includes(upper));
    return row ? String(row['MID'] || '').trim() : '';
  }

  function getAllSteelPartForTariff(tariffs) {
    console.log('[getAllSteelPartForTariff] Called with tariffs:', tariffs);
    console.log('[getAllSteelPartForTariff] steelAlumListDb length:', steelAlumListDb.length);
    
    if (!eisenmannDb.length) return 'ALL STEEL GENERIC';
    if (!tariffs || !Array.isArray(tariffs) || tariffs.length === 0) return 'ALL STEEL GENERIC';

    const allSteelRows = eisenmannDb.filter(row => {
      const p = String(row['Part Number'] || row['PRIMARY PART NUM'] || '').toUpperCase();
      return p.startsWith('ALL STEEL');
    });
    console.log('[getAllSteelPartForTariff] Found ALL STEEL parts:', allSteelRows.length);
    
    if (!allSteelRows.length) return 'ALL STEEL GENERIC';

    // Try to find a match with specific ALL STEEL PRIMARY parts using any of the tariffs
    // BUT skip exemption codes (starting with 98 or 99)
    console.log('[getAllSteelPartForTariff] Step 1: Checking for specific PRIMARY matches...');
    for (const tariff of tariffs) {
      const normTariff = String(tariff || '').trim();
      if (!normTariff) continue;
      
      // Skip exemption codes - only check actual HTS codes
      if (normTariff.startsWith('98') || normTariff.startsWith('99')) {
        console.log('[getAllSteelPartForTariff] Skipping exemption code:', normTariff);
        continue;
      }
      
      console.log('[getAllSteelPartForTariff] Checking tariff:', normTariff);
      let match = allSteelRows.find(row => {
        const partName = String(row['Part Number'] || row['PRIMARY PART NUM'] || '').toUpperCase();
        // Skip generic parts - only match specific PRIMARY parts
        if (partName.includes('GENERIC')) return false;
        
        const rowTariffs = [];
        // Try old format (Tariff1-5)
        for (let i = 1; i <= 5; i++) {
          const t = String(row[`Tariff${i}`] || '').trim();
          if (t && t !== '0') rowTariffs.push(t);
        }
        // Try new format (TARIFF NUM, TARIFF NUM_1, TARIFF NUM_10)
        ['TARIFF NUM', 'TARIFF NUM_1', 'TARIFF NUM_10'].forEach(col => {
          const t = String(row[col] || '').trim();
          if (t && t !== '0' && t !== 'nan') rowTariffs.push(t);
        });
        
        return rowTariffs.includes(normTariff);
      });

      if (match) {
        const result = String(match['Part Number'] || match['PRIMARY PART NUM'] || 'ALL STEEL GENERIC');
        console.log('[getAllSteelPartForTariff] Found specific match:', result);
        return result;
      }
    }
    console.log('[getAllSteelPartForTariff] No specific PRIMARY matches found');

    // No specific match found - check Steel_Alum_list with ALL tariffs to determine which generic to use
    // Check ALL tariffs including exemption codes
    console.log('[getAllSteelPartForTariff] Step 2: Checking Steel_Alum_list...');
    if (steelAlumListDb.length > 0) {
      console.log('[getAllSteelPartForTariff] Steel_Alum_list has', steelAlumListDb.length, 'rows');
      // Log the first row to see column names
      if (steelAlumListDb.length > 0) {
        console.log('[getAllSteelPartForTariff] First row columns:', Object.keys(steelAlumListDb[0]));
      }
      
      for (const tariff of tariffs) {
        const normTariff = String(tariff || '').trim();
        if (!normTariff) continue;
        
        // Use first 8 digits for comparison
        const mainTariffFirst8 = normTariff.substring(0, 8);
        console.log('[getAllSteelPartForTariff] Checking tariff:', normTariff, '(first 8:', mainTariffFirst8 + ')');
        
        // Check if tariff is in Steel M column
        const inSteelM = steelAlumListDb.some(row => {
          const steelM = String(row['Steel M'] || '').trim();
          if (!steelM) return false;
          // Remove decimal and get first 8 digits
          const steelMClean = steelM.replace(/\.0+$/, '');
          const steelMFirst8 = steelMClean.substring(0, 8);
          return steelMFirst8 === mainTariffFirst8;
        });
        
        if (inSteelM) {
          console.log('[getAllSteelPartForTariff] Matched Steel M! Returning ALL STEEL GENERIC - M');
          return 'ALL STEEL GENERIC - M';
        }
        
        // Check if tariff is in Steel N column
        const inSteelN = steelAlumListDb.some(row => {
          const steelN = String(row['Steel N'] || '').trim();
          if (!steelN) return false;
          // Get first 8 digits
          const steelNFirst8 = steelN.substring(0, 8);
          return steelNFirst8 === mainTariffFirst8;
        });
        
        if (inSteelN) {
          console.log('[getAllSteelPartForTariff] Matched Steel N! Returning ALL STEEL GENERIC - N');
          return 'ALL STEEL GENERIC - N';
        }
        
        console.log('[getAllSteelPartForTariff] No match in Steel M or Steel N for this tariff');
      }
    } else {
      console.log('[getAllSteelPartForTariff] Steel_Alum_list is empty!');
    }

    // Fallback to generic (no suffix)
    console.log('[getAllSteelPartForTariff] Fallback: Returning ALL STEEL GENERIC');
    return 'ALL STEEL GENERIC';
  }

  function getAllCopperPartForTariff(tariffs) {
    if (!eisenmannDb.length) return 'ALL COPPER GENERIC';
    if (!tariffs || !Array.isArray(tariffs) || tariffs.length === 0) return 'ALL COPPER GENERIC';

    const allCopperRows = eisenmannDb.filter(row => {
      const p = String(row['Part Number'] || row['PRIMARY PART NUM'] || '').toUpperCase();
      return p.startsWith('ALL COPPER');
    });
    if (!allCopperRows.length) return 'ALL COPPER GENERIC';

    // Try to find a match with any of the tariffs
    for (const tariff of tariffs) {
      const normTariff = String(tariff || '').trim();
      if (!normTariff) continue;
      
      let match = allCopperRows.find(row => {
        const rowTariffs = [];
        // Try old format (Tariff1-5)
        for (let i = 1; i <= 5; i++) {
          const t = String(row[`Tariff${i}`] || '').trim();
          if (t && t !== '0') rowTariffs.push(t);
        }
        // Try new format (TARIFF NUM, TARIFF NUM_1, TARIFF NUM_10)
        ['TARIFF NUM', 'TARIFF NUM_1', 'TARIFF NUM_10'].forEach(col => {
          const t = String(row[col] || '').trim();
          if (t && t !== '0' && t !== 'nan') rowTariffs.push(t);
        });
        
        return rowTariffs.includes(normTariff);
      });

      if (match) {
        return String(match['Part Number'] || match['PRIMARY PART NUM'] || 'ALL COPPER GENERIC');
      }
    }

    // Fallback to generic
    const generic = allCopperRows.find(row =>
      String(row['Part Number'] || row['PRIMARY PART NUM'] || '').toUpperCase().includes('ALL COPPER GENERIC')
    );
    if (generic) return String(generic['Part Number'] || generic['PRIMARY PART NUM']);
    return String(allCopperRows[0]['Part Number'] || allCopperRows[0]['PRIMARY PART NUM'] || 'ALL COPPER GENERIC');
  }

  function getAllAluminumPartForTariff(tariffs) {
    if (!eisenmannDb.length) return 'ALL ALUMINUM GENERIC';
    if (!tariffs || !Array.isArray(tariffs) || tariffs.length === 0) return 'ALL ALUMINUM GENERIC';

    const allAlumRows = eisenmannDb.filter(row => {
      const p = String(row['Part Number'] || row['PRIMARY PART NUM'] || '').toUpperCase();
      return p.startsWith('ALL ALUMINUM') || p.startsWith('ALL ALUM');
    });
    if (!allAlumRows.length) return 'ALL ALUMINUM GENERIC';

    // Try to find a match with specific ALL ALUMINUM PRIMARY parts using any of the tariffs
    // BUT skip exemption codes (starting with 98 or 99)
    for (const tariff of tariffs) {
      const normTariff = String(tariff || '').trim();
      if (!normTariff) continue;
      
      // Skip exemption codes - only check actual HTS codes
      if (normTariff.startsWith('98') || normTariff.startsWith('99')) continue;
      
      let match = allAlumRows.find(row => {
        const partName = String(row['Part Number'] || row['PRIMARY PART NUM'] || '').toUpperCase();
        // Skip generic parts - only match specific PRIMARY parts
        if (partName.includes('GENERIC')) return false;
        
        const rowTariffs = [];
        // Try old format (Tariff1-5)
        for (let i = 1; i <= 5; i++) {
          const t = String(row[`Tariff${i}`] || '').trim();
          if (t && t !== '0') rowTariffs.push(t);
        }
        // Try new format (TARIFF NUM, TARIFF NUM_1, TARIFF NUM_10)
        ['TARIFF NUM', 'TARIFF NUM_1', 'TARIFF NUM_10'].forEach(col => {
          const t = String(row[col] || '').trim();
          if (t && t !== '0' && t !== 'nan') rowTariffs.push(t);
        });
        
        return rowTariffs.includes(normTariff);
      });

      if (match) {
        return String(match['Part Number'] || match['PRIMARY PART NUM'] || 'ALL ALUMINUM GENERIC');
      }
    }

    // No specific match found - check Steel_Alum_list with ALL tariffs to determine which generic to use
    // Check ALL tariffs including exemption codes
    if (steelAlumListDb.length > 0) {
      for (const tariff of tariffs) {
        const normTariff = String(tariff || '').trim();
        if (!normTariff) continue;
        
        // Use first 8 digits for comparison
        const mainTariffFirst8 = normTariff.substring(0, 8);
        
        // Check if tariff is in Aluminum List K column
        const inAlumK = steelAlumListDb.some(row => {
          const alumK = String(row['Aluminum List K'] || '').trim();
          if (!alumK) return false;
          // Remove decimal and get first 8 digits
          const alumKClean = alumK.replace(/\.0+$/, '');
          const alumKFirst8 = alumKClean.substring(0, 8);
          return alumKFirst8 === mainTariffFirst8;
        });
        
        if (inAlumK) {
          return 'ALL ALUMINUM GENERIC - K';
        }
        
        // Check if tariff is in Aluminum List J column
        const inAlumJ = steelAlumListDb.some(row => {
          const alumJ = String(row['Aluminum List J'] || '').trim();
          if (!alumJ) return false;
          // Remove decimal and get first 8 digits
          const alumJClean = alumJ.replace(/\.0+$/, '');
          const alumJFirst8 = alumJClean.substring(0, 8);
          return alumJFirst8 === mainTariffFirst8;
        });
        
        if (inAlumJ) {
          return 'ALL ALUMINUM GENERIC - J';
        }
      }
    }

    // Fallback to generic (no suffix)
    return 'ALL ALUMINUM GENERIC';
  }

  // ========= UPLOAD HANDLERS (unchanged) =========
  uploadBox.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', e => {
    const f = e.target.files && e.target.files[0];
    if (f) handleFile(f);
  });

  uploadBox.addEventListener('dragover', e => {
    e.preventDefault();
    uploadBox.classList.add('dragover');
  });
  uploadBox.addEventListener('dragleave', () => uploadBox.classList.remove('dragover'));
  uploadBox.addEventListener('drop', e => {
    e.preventDefault();
    uploadBox.classList.remove('dragover');
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if (f) handleFile(f);
  });

  function showAlert(msg, type = 'info') {
    alertBox.textContent = msg;
    alertBox.style.display = 'block';
    if (type === 'error') {
      alertBox.style.background = '#f8d7da';
      alertBox.style.color = '#721c24';
      alertBox.style.border = '1px solid #f5c6cb';
    } else {
      alertBox.style.background = '#d4edda';
      alertBox.style.color = '#155724';
      alertBox.style.border = '1px solid #c3e6cb';
    }
    setTimeout(() => { alertBox.style.display = 'none'; }, 4000);
  }

  // ========= HELPER FUNCTIONS =========
  function parseFloatSafe(v) {
    if (v == null) return NaN;
    const t = String(v).replace(/,/g, '').trim();
    const n = parseFloat(t);
    return isNaN(n) ? NaN : n;
  }

  function isPdfFile(file) {
    const nameOk = (file.name || '').toLowerCase().endsWith('.pdf');
    const typeOk = (file.type || '').toLowerCase() === 'application/pdf';
    return nameOk || typeOk;
  }

  // Helper to extract all metal content declarations from an invoice block
  function extractAllMetalContent(text) {
    const noContentPattern = /Does\s+not\s+contain\s+any\s+aluminum[,\s]+Steel\s+or\s+Copper/gi;
    const noContentMatches = [...text.matchAll(noContentPattern)];
    
    const steelPattern = /Steel\s*content\s*(\d+)\s*%\s*:\s*([\d,\.]+)\s*kg/gi;
    const copperPattern = /Copper\s*content\s*(\d+)\s*%\s*:\s*([\d,\.]+)\s*kg/gi;
    const aluminumPattern = /Aluminum\s*content\s*(\d+)\s*%\s*:\s*([\d,\.]+)\s*kg/gi;
    
    const steelMatches = [...text.matchAll(steelPattern)];
    const copperMatches = [...text.matchAll(copperPattern)];
    const aluminumMatches = [...text.matchAll(aluminumPattern)];
    
    const allDeclarations = [];
    
    noContentMatches.forEach(m => {
      allDeclarations.push({ position: m.index, type: 'none', match: m });
    });
    
    steelMatches.forEach(m => {
      allDeclarations.push({ position: m.index, type: 'steel', match: m });
    });
    
    copperMatches.forEach(m => {
      allDeclarations.push({ position: m.index, type: 'copper', match: m });
    });
    
    aluminumMatches.forEach(m => {
      allDeclarations.push({ position: m.index, type: 'aluminum', match: m });
    });
    
    allDeclarations.sort((a, b) => a.position - b.position);
    
    let currentGroup = null;
    const groups = [];
    
    allDeclarations.forEach((decl) => {
      const needNewGroup = !currentGroup || 
                          decl.type === 'none' ||
                          currentGroup.lastType === 'none' ||
                          (decl.position - currentGroup.lastPosition) > 50 ||
                          (currentGroup.lastType === decl.type && decl.type !== 'none');
      
      if (needNewGroup) {
        currentGroup = {
          metals: [],
          noContent: false,
          lastPosition: decl.position,
          lastType: decl.type
        };
        groups.push(currentGroup);
      }
      
      currentGroup.lastPosition = decl.position;
      currentGroup.lastType = decl.type;
      
      if (decl.type === 'none') {
        currentGroup.noContent = true;
      } else {
        const percentage = parseInt(decl.match[1]);
        const weight = parseFloat(decl.match[2].replace(',', '.'));
        
        const contextStart = Math.max(0, decl.position - 50);
        const contextEnd = Math.min(text.length, decl.position + 300);
        const context = text.slice(contextStart, contextEnd);
        
        const metal = {
          type: decl.type.charAt(0).toUpperCase() + decl.type.slice(1),
          percentage: percentage,
          weight: weight,
          unit: 'kg',
          mixture: !context.includes('No mixture'),
          countryMeltPour: extractCountryMeltPour(context)
        };
        
        currentGroup.metals.push(metal);
      }
    });
    
    const result = groups.map(group => {
      if (group.metals.length > 0) {
        return { hasMetals: true, metals: group.metals, noContent: false };
      } else if (group.noContent) {
        return { hasMetals: false, metals: [], noContent: true };
      } else {
        return { hasMetals: false, metals: [], noContent: false };
      }
    });
    
    return result;
  }

  function extractCountryMeltPour(text) {
    let countryMatch = text.match(/Country\s*of\s*Melt\s*&\s*Pour\s*:\s*(\w+)/i);
    if (!countryMatch) {
      countryMatch = text.match(/Country\s*of\s*Melt\s*and\s*Pour\s*:\s*(\w+)/i);
    }
    if (countryMatch) {
      const code = countryMatch[1].toUpperCase();
      const countryMap = {
        'GER': 'Germany', 'USA': 'United States', 'CHN': 'China', 'JPN': 'Japan',
        'FRA': 'France', 'ITA': 'Italy', 'UK': 'United Kingdom', 'GB': 'United Kingdom',
        'DE': 'Germany', 'DEU': 'Germany'
      };
      return countryMap[code] || code;
    }
    return null;
  }

  // ========= PDF PARSING =========
  async function handleFile(file) {
    if (!isPdfFile(file)) {
      showAlert('Please upload a PDF file.', 'error');
      return;
    }
    uploadedPdfName = (file.name || '').replace(/\.pdf$/i, '');

    uploadSec.style.display = 'none';
    loadingPane.style.display = 'block';

    try {
      const arrayBuffer = await file.arrayBuffer();
      const uint8 = new Uint8Array(arrayBuffer);
      const pdf = await pdfjsLib.getDocument({ data: uint8 }).promise;

      let fullText = '';
      for (let i = 1; i <= pdf.numPages; i++) {
        try {
          const page = await pdf.getPage(i);
          const textContent = await page.getTextContent({ includeMarkedContent: true });
          const items = (textContent && Array.isArray(textContent.items)) ? textContent.items : [];
          const pageText = items
            .map(it => (it && typeof it.str === 'string') ? it.str : '')
            .join(' ');
          fullText += pageText + '\n';
        } catch (perPageErr) {
          console.warn('Failed to read page', i, perPageErr);
        }
      }

      if (!fullText.trim()) {
        showAlert('The PDF had no extractable text (might be scanned).', 'error');
        uploadSec.style.display = 'block';
        return;
      }

      parseInvoices(fullText);

      if (allData.length) {
        const invoiceCount = new Set(allData.map(d => d.invoice_number)).size;
        showAlert(`Parsed ${invoiceCount} invoice(s) and ${allData.length} line item(s).`, 'success');
        setupInterface();
      } else {
        showAlert('No Eisenmann invoice lines were found in the PDF.', 'error');
        uploadSec.style.display = 'block';
      }
    } catch (err) {
      console.error('PDF processing error:', err);
      showAlert('Error processing PDF: ' + (err.message || String(err)), 'error');
      uploadSec.style.display = 'block';
    } finally {
      loadingPane.style.display = 'none';
    }
  }

  function setupInterface() {
    loadingPane.style.display = 'none';
    controls.style.display = 'flex';
    stats.style.display = 'grid';
    tableCont.style.display = 'block';

    invoiceSelect.innerHTML = '<option value="">Select an invoice...</option>';
    invoiceOrder.forEach(inv => {
      const opt = document.createElement('option');
      opt.value = inv;
      opt.textContent = inv;
      invoiceSelect.appendChild(opt);
    });

    currentInvoice = invoiceOrder[0];
    invoiceSelect.value = currentInvoice;
    loadInvoiceData();
  }

  function parseInvoices(text) {
    allData = [];
    invoiceOrder = [];
    text = String(text || '');

    const invoicePattern = /Invoice no\. \/ Date:\s*(\d+)\s*\/\s*(\d{2}\/\d{2}\/\d{4})/g;
    const headers = [];
    let m;
    while ((m = invoicePattern.exec(text)) !== null) {
      headers.push({
        index: m.index,
        invoice_number: m[1],
        invoice_date: m[2]
      });
    }
    headers.push({ index: text.length, invoice_number: null, invoice_date: null });

    const linePattern = /(\d{5,6})\s+([A-Z0-9]+)\s+([\d.,]+)\s+([A-Z]+)\s+([\d.,]+)\s+USD\s+([\d.,]+)\s+([A-Z]+)\s+([\d.,]+)/g;

    for (let i = 0; i < headers.length - 1; i++) {
      const start = headers[i].index;
      const end   = headers[i + 1].index;
      const invNum  = headers[i].invoice_number;
      const invDate = headers[i].invoice_date;

      if (!invNum) continue;
      const block = text.slice(start, end);

      let invoiceTotal = '';
      const totalMatch = block.match(/Net\s*amount\s+([\d.,]+)/i);
      if (totalMatch) invoiceTotal = totalMatch[1].replace(/,/g, '');

      const lineMatches = [...block.matchAll(linePattern)];
      if (!lineMatches.length) {
        allData.push({
          invoice_number: invNum,
          invoice_date: invDate,
          invoice_total: invoiceTotal,
          supplier: 'Eisenmann GmbH',
          position: '',
          part_number: '',
          quantity: '',
          unit: '',
          unit_price: '',
          line_total: '',
          net_weight: '',
          country_of_origin: '',
          hts_code: '',
          metal_type: '',
          metal_percentage: '',
          metal_weight: '',
          metal_country: '',
          metal_content: { hasMetals: false, metals: [], noContent: false }
        });
        continue;
      }

      const metalContents = extractAllMetalContent(block);

      lineMatches.forEach((lm, idx) => {
        const position = lm[1];
        const material = lm[2];
        const qty1     = (lm[3] || '').replace(/,/g, '');
        const unit1    = lm[4];
        const unitPrice = (lm[5] || '').replace(/,/g, '');
        const rawTotal  = lm[8] || '';

        const cleanTotal = rawTotal
          .replace(/[^0-9.,]/g, '')
          .replace(/,/g, '');

        const itemStart = lm.index || 0;
        const itemEnd   = (idx + 1 < lineMatches.length)
          ? (lineMatches[idx + 1].index || block.length)
          : block.length;
        const itemSection = block.slice(itemStart, itemEnd);

        let hts = '';
        const htsMatch = itemSection.match(/Commodity Code\s*\/\s*Import Code Number:\s*([0-9]+)/i);
        if (htsMatch) hts = htsMatch[1];

        let coo = '';
        const cooMatch = itemSection.match(/Country of origin:\s*([A-Za-z ]+)/i);
        if (cooMatch) coo = cooMatch[1].trim();
        if (coo.toLowerCase().includes('germany')) coo = 'DE';

        const metalContent = metalContents[idx] || { hasMetals: false, metals: [], noContent: false };
        
        let metalType = '';
        let metalPercentage = '';
        let metalWeight = '';
        let metalCountry = '';
        
        if (metalContent.noContent) {
          metalType = 'None';
        } else if (metalContent.hasMetals && metalContent.metals.length > 0) {
          const metal = metalContent.metals[0];
          metalType = metal.type;
          metalPercentage = metal.percentage;
          metalWeight = metal.weight;
          metalCountry = metal.countryMeltPour || '';
        }
        
        let netWeight = '';
        if (metalContent.hasMetals && metalContent.metals.length > 0) {
          const fullMetal = metalContent.metals.find(m => m.percentage === 100);
          if (fullMetal) {
            netWeight = fullMetal.weight.toString();
          }
        }

        allData.push({
          invoice_number: invNum,
          invoice_date: invDate,
          invoice_total: invoiceTotal,
          supplier: 'Eisenmann GmbH',
          position: position,
          part_number: material,
          quantity: qty1,
          unit: unit1,
          unit_price: unitPrice,
          line_total: cleanTotal,
          net_weight: netWeight,
          country_of_origin: coo,
          hts_code: hts,
          metal_type: metalType,
          metal_percentage: metalPercentage,
          metal_weight: metalWeight,
          metal_country: metalCountry,
          metal_content: metalContent
        });
      });
    }

    invoiceOrder = [...new Set(allData.map(r => r.invoice_number))];
  }

  // ========= TABLE RENDERING (unchanged) =========
  invoiceSelect.addEventListener('change', e => {
    currentInvoice = e.target.value;
    if (currentInvoice) loadInvoiceData();
  });

  function loadInvoiceData() {
    const rows = allData.filter(r => r.invoice_number === currentInvoice);
    tbody.innerHTML = '';

    rows.forEach((item, localIdx) => {
      const globalIdx = allData.indexOf(item);
      const tr = document.createElement('tr');

      function makeCell(field, readonly = false) {
        const td = document.createElement('td');
        const inp = document.createElement('input');
        inp.type = 'text';
        inp.value = item[field] || '';
        inp.dataset.index = globalIdx;
        inp.dataset.field = field;
        if (readonly) {
          inp.className = 'readonly';
          inp.readOnly = true;
        }
        inp.addEventListener('change', onCellChange);
        td.appendChild(inp);
        return td;
      }

      tr.appendChild(makeCell('position', true));
      tr.appendChild(makeCell('part_number'));
      tr.appendChild(makeCell('quantity'));
      tr.appendChild(makeCell('unit'));
      tr.appendChild(makeCell('unit_price'));
      tr.appendChild(makeCell('line_total'));
      tr.appendChild(makeCell('net_weight'));
      tr.appendChild(makeCell('country_of_origin'));

      // Metal Type - dropdown
      const tdMetalType = document.createElement('td');
      const selectMetalType = document.createElement('select');
      selectMetalType.style.width = '100%';
      selectMetalType.style.padding = '6px';
      selectMetalType.style.border = '1px solid #ced4da';
      selectMetalType.style.borderRadius = '3px';
      selectMetalType.style.fontSize = '13px';
      selectMetalType.style.background = '#fff';
      selectMetalType.dataset.index = globalIdx;
      selectMetalType.dataset.field = 'metal_type';
      selectMetalType.addEventListener('change', onCellChange);
      
      const metalOptions = ['', 'Steel', 'Copper', 'Aluminum', 'None'];
      metalOptions.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt;
        option.textContent = opt;
        if (opt === item.metal_type) option.selected = true;
        selectMetalType.appendChild(option);
      });
      tdMetalType.appendChild(selectMetalType);
      tr.appendChild(tdMetalType);

      tr.appendChild(makeCell('metal_percentage'));
      tr.appendChild(makeCell('metal_weight'));
      tr.appendChild(makeCell('metal_country'));

      const tdAct = document.createElement('td');
      tdAct.className = 'actions';
      const btnAdd = document.createElement('button');
      btnAdd.textContent = '+ Below';
      btnAdd.className = 'btn-light';
      btnAdd.addEventListener('click', () => addRowBelow(globalIdx));
      const btnDel = document.createElement('button');
      btnDel.textContent = 'Delete';
      btnDel.className = 'btn-danger';
      btnDel.addEventListener('click', () => deleteRow(globalIdx));
      tdAct.appendChild(btnAdd);
      tdAct.appendChild(btnDel);
      tr.appendChild(tdAct);

      tbody.appendChild(tr);
    });

    updateStats();
  }

  function onCellChange(e) {
    const idx = parseInt(e.target.dataset.index, 10);
    const field = e.target.dataset.field;
    if (Number.isNaN(idx) || !field) return;
    allData[idx][field] = e.target.value;
    updateStats();
  }

  function updateStats() {
    const rows = allData.filter(r => r.invoice_number === currentInvoice);

    const statInvoice  = document.getElementById('statInvoice');
    const statDate     = document.getElementById('statDate');
    const statSupplier = document.getElementById('statSupplier');
    const statItems    = document.getElementById('statItems');
    const statTotal    = document.getElementById('statTotal');
    const statSum      = document.getElementById('statSum');
    const statDiff     = document.getElementById('statDiff');

    statInvoice.textContent = currentInvoice || '-';

    if (rows.length) {
      statDate.value     = rows[0].invoice_date || '';
      statSupplier.value = rows[0].supplier || 'Eisenmann GmbH';
      statItems.textContent = rows.length;
      statTotal.value    = rows[0].invoice_total || '';
    } else {
      statDate.value = '';
      statSupplier.value = '';
      statItems.textContent = '0';
      statTotal.value = '';
    }

    let sum = 0;
    rows.forEach(r => {
      const v = parseFloatSafe(r.line_total);
      if (!isNaN(v)) sum += v;
    });
    statSum.textContent = '$' + sum.toFixed(2);

    let diff = 0;
    const invTotal = parseFloatSafe(rows[0]?.invoice_total || '');
    if (!isNaN(invTotal)) diff = invTotal - sum;

    statDiff.textContent = '$' + diff.toFixed(2);
    statDiff.classList.remove('success','error');
    if (!isNaN(invTotal)) {
      if (Math.abs(diff) < 0.01) statDiff.classList.add('success');
      else statDiff.classList.add('error');
    }
  }

  function parseFloatSafe(val) {
    if (!val) return NaN;
    const s = String(val).replace(/,/g, '').trim();
    return s ? parseFloat(s) : NaN;
  }

  function updateInvoiceField(field, value) {
    allData.forEach(r => {
      if (r.invoice_number === currentInvoice) {
        r[field] = value;
      }
    });
    updateStats();
  }

  function updateInvoiceTotal(value) {
    updateInvoiceField('invoice_total', value);
  }

  function addRowBelow(globalIdx) {
    const base = allData[globalIdx];
    if (!base) return;
    const newRow = {
      invoice_number: base.invoice_number,
      invoice_date: base.invoice_date,
      invoice_total: base.invoice_total,
      supplier: base.supplier,
      position: '',
      part_number: '',
      quantity: '',
      unit: '',
      unit_price: '',
      line_total: '',
      net_weight: '',
      country_of_origin: base.country_of_origin || '',
      hts_code: base.hts_code || '',
      metal_type: '',
      metal_percentage: '',
      metal_weight: '',
      metal_country: '',
      metal_content: { hasMetals: false, metals: [], noContent: false }
    };
    allData.splice(globalIdx + 1, 0, newRow);
    loadInvoiceData();
  }

  function deleteRow(globalIdx) {
    if (globalIdx < 0 || globalIdx >= allData.length) return;
    allData.splice(globalIdx, 1);
    loadInvoiceData();
  }

  function resetUpload() {
    allData = [];
    invoiceOrder = [];
    currentInvoice = '';
    uploadedPdfName = '';
    fileInput.value = '';
    invoiceSelect.innerHTML = '<option value="">Select an invoice...</option>';
    controls.style.display = 'none';
    stats.style.display = 'none';
    tableCont.style.display = 'none';
    uploadSec.style.display = 'block';
  }

  function debugDumpData() {
    console.log('========== DEBUG DATA DUMP ==========');
    console.log('Total rows in allData:', allData.length);
    console.log('Invoice order:', invoiceOrder);
    console.log('Current invoice:', currentInvoice);
    
    console.log('\nFirst 5 rows:');
    allData.slice(0, 5).forEach((row, idx) => {
      console.log(`\nRow ${idx}:`, {
        invoice: row.invoice_number,
        position: row.position,
        part: row.part_number,
        hasMetalContent: !!row.metal_content,
        metalContent: row.metal_content
      });
    });
    
    console.log('\nFull allData:', allData);
  }

  function exportToDescartes() {
    if (!allData.length) {
      showAlert('No data to export.', 'error');
      return;
    }

    const exportRows = [];

    allData.forEach(item => {
      const supplierMid = lookupSupplierMid(item.supplier);
      const metalContent = item.metal_content || { hasMetals: false, metals: [] };
      
      // Check if this is 100% metal (single metal type at 100% with no other content)
      const metalWeight = parseFloatSafe(item.metal_weight);
      const metalPercentage = parseFloatSafe(item.metal_percentage);
      const netWeight = parseFloatSafe(item.net_weight);
      
      const is100PercentMetal = metalContent.hasMetals && 
                                metalContent.metals.length === 1 &&
                                metalPercentage === 100 &&
                                !isNaN(metalWeight) && metalWeight > 0 &&
                                (!netWeight || isNaN(netWeight) || Math.abs(metalWeight - netWeight) <= netWeight * 0.01);
      
      if (is100PercentMetal) {
        // Use ALL STEEL/COPPER/ALUMINUM part number based on base tariff
        const tariffs = lookupTariffsByPart(item.part_number);
        const metal = metalContent.metals[0];
        
        let allMetalPart = '';
        if (metal.type === 'Steel') {
          allMetalPart = getAllSteelPartForTariff(tariffs);
        } else if (metal.type === 'Copper') {
          allMetalPart = getAllCopperPartForTariff(tariffs);
        } else if (metal.type === 'Aluminum') {
          allMetalPart = getAllAluminumPartForTariff(tariffs);
        }
        
        // Keep original part number for BuyerPartNumber, use ALL METAL part for SupplierPartNumber
        const baseRow = buildBaseRow(item, supplierMid, item.part_number, allMetalPart);
        fillTariffs(baseRow, allMetalPart, item.net_weight || metalWeight.toString());
        exportRows.push(baseRow);
        
      } else {
        // Normal processing - base row + separate metal rows
        const baseRow = buildBaseRow(item, supplierMid, item.part_number, item.part_number);
        fillTariffs(baseRow, item.part_number, item.net_weight);
        exportRows.push(baseRow);

        // Add metal content rows if present
        if (metalContent.hasMetals && metalContent.metals.length > 0) {
          metalContent.metals.forEach(metal => {
            const metalRow = buildMetalRow(item, supplierMid, metal);
            exportRows.push(metalRow);
          });
        }
      }
    });

    // Create workbook and export
    const headers = [
      'InvoiceNumber','InvoiceDate','InvoiceTotal','SupplierMID','SupplierName',
      'BuyerPartNumber','SupplierPartNumber','Quantity','UnitOfMeasure','Description',
      'UnitPrice','ItemTotal','CurrencyCode','ExchangeRate','CountryOfOrigin',
      'CountryOfExport','DateOfExport','PortOfLading','RelatedParty','PO_Number',
      'PO_Date','GrossWeight','GrossWeightUnit','NetWeight','TariffNumber',
      'TariffDescription','Quantity1','UnitOfMeasure1','Quantity2','UnitOfMeasure2',
      'Quantity3','UnitOfMeasure3','PrimarySPI','SecondarySPI','DeliverTo','SoldTo',
      'SellerMID','ShipperMID','EntryDate','ArrivalDate','Carrier','Vessel','Voyage',
      'PortOfEntry','PortOfUnloading','LocationCode','TotalCharges','BillOfLadingNumber',
      'Container','SecondaryTariffNumber','SecondaryTariffdescription','Secondary Quantity1',
      'Secondaryunitofmeasure1','secondaryquantity2','secondaryunitofmeasure2',
      'secondaryquantity3','secondaryunitofmeasure3','secondaryvalue','FTZStatus',
      'FTZPrivilegedDate\u00a0','ThirdTariffNumber','ThirdTariffDescription',
      'ThirdTariffQuantity1','ThirdTariffUnitofMeasure1','ThirdTariffQuantity2',
      'ThirdTariffUnitofMeasure2','ThirdTariffQuantity3','ThirdTariffUnitofMeasure3',
      'Third Value','4TariffNumber','4TariffDescription','4TariffQuantity1',
      '4TariffUnitofMeasure1','4TariffQuantity2','4TariffUnitofMeasure2',
      '4TariffQuantity3','4TariffUnitofMeasure3','4 Value',
      '5TariffNumber','5TariffDescription','5TariffQuantity1',
      '5TariffUnitofMeasure1','5TariffQuantity2','5TariffUnitofMeasure2',
      '5TariffQuantity3','5TariffUnitofMeasure3','5 Value'
    ];

    const aoa = [headers];
    exportRows.forEach(r => {
      aoa.push(headers.map(h => (r[h] != null ? r[h] : '')));
    });

    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(aoa);
    XLSX.utils.book_append_sheet(wb, ws, 'DescartesUpload');

    const fname = (uploadedPdfName ? uploadedPdfName + '_' : '') + 'descartes_ci_upload.xlsx';
    XLSX.writeFile(wb, fname);
    
    showAlert(`Exported ${exportRows.length} rows to ${fname}`, 'success');
  }

  function buildBaseRow(item, supplierMid, buyerPartNum, supplierPartNum) {
    return {
      'InvoiceNumber': item.invoice_number || '',
      'InvoiceDate': item.invoice_date || '',
      'InvoiceTotal': item.invoice_total || '',
      'SupplierMID': supplierMid,
      'SupplierName': item.supplier || '',
      'BuyerPartNumber': buyerPartNum,
      'SupplierPartNumber': supplierPartNum,
      'Quantity': item.quantity || '',
      'UnitOfMeasure': item.unit || 'ST',
      'Description': '',
      'UnitPrice': item.unit_price || '',
      'ItemTotal': item.line_total || '',
      'CurrencyCode': 'USD',
      'ExchangeRate': '',
      'CountryOfOrigin': item.country_of_origin || 'DE',
      'CountryOfExport': 'DE',
      'DateOfExport': '',
      'PortOfLading': '',
      'RelatedParty': '',
      'PO_Number': '',
      'PO_Date': '',
      'GrossWeight': '',
      'GrossWeightUnit': '',
      'NetWeight': item.net_weight || '',
      'TariffNumber': '',
      'TariffDescription': '',
      'Quantity1': '',
      'UnitOfMeasure1': '',
      'Quantity2': '',
      'UnitOfMeasure2': '',
      'Quantity3': '',
      'UnitOfMeasure3': '',
      'PrimarySPI': '',
      'SecondarySPI': '',
      'DeliverTo': '',
      'SoldTo': '',
      'SellerMID': '',
      'ShipperMID': '',
      'EntryDate': '',
      'ArrivalDate': '',
      'Carrier': '',
      'Vessel': '',
      'Voyage': '',
      'PortOfEntry': '',
      'PortOfUnloading': '',
      'LocationCode': '',
      'TotalCharges': '',
      'BillOfLadingNumber': '',
      'Container': '',
      'SecondaryTariffNumber': '',
      'SecondaryTariffdescription': '',
      'Secondary Quantity1': '',
      'Secondaryunitofmeasure1': '',
      'secondaryquantity2': '',
      'secondaryunitofmeasure2': '',
      'secondaryquantity3': '',
      'secondaryunitofmeasure3': '',
      'secondaryvalue': '',
      'FTZStatus': '',
      'FTZPrivilegedDate\u00a0': '',
      'ThirdTariffNumber': '',
      'ThirdTariffDescription': '',
      'ThirdTariffQuantity1': '',
      'ThirdTariffUnitofMeasure1': '',
      'ThirdTariffQuantity2': '',
      'ThirdTariffUnitofMeasure2': '',
      'ThirdTariffQuantity3': '',
      'ThirdTariffUnitofMeasure3': '',
      'Third Value': '',
      '4TariffNumber': '',
      '4TariffDescription': '',
      '4TariffQuantity1': '',
      '4TariffUnitofMeasure1': '',
      '4TariffQuantity2': '',
      '4TariffUnitofMeasure2': '',
      '4TariffQuantity3': '',
      '4TariffUnitofMeasure3': '',
      '4 Value': '',
      '5TariffNumber': '',
      '5TariffDescription': '',
      '5TariffQuantity1': '',
      '5TariffUnitofMeasure1': '',
      '5TariffQuantity2': '',
      '5TariffUnitofMeasure2': '',
      '5TariffQuantity3': '',
      '5TariffUnitofMeasure3': '',
      '5 Value': ''
    };
  }

  function fillTariffs(row, partNumber, netWeight) {
    const tariffs = lookupTariffsByPart(partNumber);
    const tariffFields = ['TariffNumber', 'SecondaryTariffNumber', 'ThirdTariffNumber', '4TariffNumber', '5TariffNumber'];

    tariffs.forEach((tariff, idx) => {
      if (idx < tariffFields.length) {
        row[tariffFields[idx]] = tariff;
        
        const startsWithExempt = String(tariff).startsWith('98') || String(tariff).startsWith('99');
        if (!startsWithExempt) {
          const uomInfo = lookupHtsUom(tariff);
          
          if (idx === 0) {
            row['Quantity1'] = netWeight;
            row['UnitOfMeasure1'] = uomInfo.uom1;
            if (uomInfo.uom2) {
              row['Quantity2'] = netWeight;
              row['UnitOfMeasure2'] = uomInfo.uom2;
            }
          } else if (idx === 1) {
            row['Secondary Quantity1'] = netWeight;
            row['Secondaryunitofmeasure1'] = uomInfo.uom1;
            if (uomInfo.uom2) {
              row['secondaryquantity2'] = netWeight;
              row['secondaryunitofmeasure2'] = uomInfo.uom2;
            }
          } else if (idx === 2) {
            row['ThirdTariffQuantity1'] = netWeight;
            row['ThirdTariffUnitofMeasure1'] = uomInfo.uom1;
            if (uomInfo.uom2) {
              row['ThirdTariffQuantity2'] = netWeight;
              row['ThirdTariffUnitofMeasure2'] = uomInfo.uom2;
            }
          } else if (idx === 3) {
            row['4TariffQuantity1'] = netWeight;
            row['4TariffUnitofMeasure1'] = uomInfo.uom1;
            if (uomInfo.uom2) {
              row['4TariffQuantity2'] = netWeight;
              row['4TariffUnitofMeasure2'] = uomInfo.uom2;
            }
          } else if (idx === 4) {
            row['5TariffQuantity1'] = netWeight;
            row['5TariffUnitofMeasure1'] = uomInfo.uom1;
            if (uomInfo.uom2) {
              row['5TariffQuantity2'] = netWeight;
              row['5TariffUnitofMeasure2'] = uomInfo.uom2;
            }
          }
        }
      }
    });

    // Special handling for ALL STEEL, ALL COPPER, ALL ALUMINUM parts
    const partUpper = String(partNumber).toUpperCase();
    if (partUpper.startsWith('ALL STEEL') || partUpper.startsWith('ALL COPPER') || partUpper.startsWith('ALL ALUMINUM')) {
      if (tariffs.length > 2 && tariffs[2]) {
        row['ThirdTariffQuantity1'] = netWeight;
      }
      row['TariffNumber'] = '';
      row['ThirdTariffUnitofMeasure1'] = '';
      row['Secondary Quantity1'] = netWeight;
    }
  }

  function buildMetalRow(item, supplierMid, metal) {
    const metalRow = buildBaseRow(item, supplierMid, '', '');
    
    const metalType = metal.type.toLowerCase();
    if (metalType === 'steel') {
      metalRow['BuyerPartNumber'] = 'STEEL EXCL';
      metalRow['SupplierPartNumber'] = 'STEEL EXCL';
      metalRow['TariffNumber'] = '99030133';
      metalRow['SecondaryTariffNumber'] = '99038191';
    } else if (metalType === 'aluminum') {
      metalRow['BuyerPartNumber'] = 'ALUM EXCL';
      metalRow['SupplierPartNumber'] = 'ALUM EXCL';
      metalRow['TariffNumber'] = '99030133';
      metalRow['SecondaryTariffNumber'] = '99038508';
    } else if (metalType === 'copper') {
      metalRow['BuyerPartNumber'] = 'COPPER EXCL';
      metalRow['SupplierPartNumber'] = 'COPPER EXCL';
      metalRow['TariffNumber'] = '99030133';
    }
    
    const metalWeight = String(metal.weight || '');
    metalRow['NetWeight'] = metalWeight;
    metalRow['Quantity'] = metalWeight;
    metalRow['Secondary Quantity1'] = metalWeight;
    metalRow['Secondaryunitofmeasure1'] = 'KG';
    metalRow['ItemTotal'] = '0';
    metalRow['UnitPrice'] = '0';
    
    if (metal.countryMeltPour) {
      metalRow['CountryOfOrigin'] = metal.countryMeltPour;
    }
    
    return metalRow;
  }
</script>
</body>
</html>
